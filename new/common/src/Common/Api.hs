{-# LANGUAGE UndecidableInstances #-}
{-# LANGUAGE PolyKinds, DataKinds #-}

{-# OPTIONS_GHC -Wno-redundant-constraints #-} --TODO: There are a lot of redundant constraints generated by the TH in this module; we need to get rid of them
module Common.Api where

import Control.Lens
import Common.Schema
import Data.Aeson (FromJSON (..), ToJSON (..))
import Data.Aeson.GADT.TH
import Data.AppendMap ()
import Obelisk.View.DMap
import Data.Constraint
import Data.Constraint.Extras
import Data.Constraint.Extras.TH
import Data.Monoid
import Data.Text (Text)
import Obelisk.Aeson.Orphans ()
import Obelisk.Auth
import Obelisk.View.Table
import Obelisk.View.Auth
import Obelisk.View.Orphans () -- For Compose instances
import Obelisk.View.Misc
import Obelisk.View.Coverable
import Data.GADT.Show.TH
import Data.GADT.Compare.TH
import Data.Dependent.Map (DMap)
import qualified Data.Dependent.Map as DMap
import Data.These
import Data.These.Lens
import Debug.Trace
import Data.Align
import Data.Witherable
import Data.Patch
import Obelisk.View.Iv.Class
import Obelisk.View.These1
import Obelisk.View.Unitary
import Obelisk.View.IdentityInterface

import Obelisk.Auth.Bearer.Common.Sign
import Obelisk.Auth.EmailAndPassword.Common

import GHC.Generics

type Password = Text

data MyRequest token a where
  MyRequest_Public :: PublicMyRequest a -> MyRequest token a
  MyRequest_Private :: token -> PrivateMyRequest a -> MyRequest token a --TODO: result should be (Either () a)

deriving instance Show token => Show (MyRequest token a) --TODO: Do something about logging sensitive data
deriving instance Show (PublicMyRequest a)
deriving instance Show (PrivateMyRequest a)

mapMyRequestToken
  :: (token -> token')
  -> MyRequest token a
  -> MyRequest token' a
mapMyRequestToken f = \case
  MyRequest_Public r -> MyRequest_Public r
  MyRequest_Private t r -> MyRequest_Private (f t) r

data PublicMyRequest a where
  PublicMyRequest_Signup
    :: Text  -- User's handle
    -> EmailAddress
    -> PublicMyRequest ()
  PublicMyRequest_Auth :: AuthRequest (Signed AuthToken) a -> PublicMyRequest a

data PrivateMyRequest a where
  PrivateMyRequest_AddChannel :: Text -> PrivateMyRequest (PrimaryKey Channel Identity)
  PrivateMyRequest_Send :: PrimaryKey Channel Identity -> Text -> PrivateMyRequest (PrimaryKey Message Identity)

deriveJSONGADT ''PublicMyRequest
deriveJSONGADT ''PrivateMyRequest
deriveArgDict ''PrivateMyRequest
deriveArgDict ''PublicMyRequest

deriveArgDict ''MyRequest

data PullArg k a where
  PullArg :: k a -> PullArg k (Pull a)

data MyViewKey token a where
  MyViewKey_Public :: MyViewKey token (DMapInterface MyViewKeyPublic IdentityInterface)
  MyViewKey_Private :: MyViewKey token (MapInterface token (AuthenticatedInterface (DMapInterface MyViewKeyPrivate IdentityInterface)))

data MyViewKeyPublic a where
  MyViewKeyPublic_NumMessages :: MyViewKeyPublic (SumInterface Int)
  MyViewKeyPublic_NumUsers :: MyViewKeyPublic (SumInterface Int)

data MyViewKeyPrivate (a :: Interface *) where
  MyViewKeyPrivate_MyChannels :: MyViewKeyPrivate (AppInterface TableInterface (LiftInterface (Channel :*: ChannelMember)))
  MyViewKeyPrivate_ChannelMessages :: PrimaryKey Channel Identity -> MyViewKeyPrivate (AppInterface TableInterface (LiftInterface Message))
  MyViewKeyPrivate_User :: PrimaryKey User Identity -> MyViewKeyPrivate (AppInterface TableInterface (LiftInterface User))

deriving instance Show (MyViewKey token a)
deriving instance Show (MyViewKeyPublic a)
deriving instance Show (MyViewKeyPrivate a)

--TODO: Parameterize on token type
type MyView = DMapInterface (MyViewKey (Signed AuthToken)) IdentityInterface

type MyView' = Pull MyView

myViewPullCovToPushCov :: Cov (Pull MyView) -> Cov (Push MyView)
myViewPullCovToPushCov = DMap.mapWithKey $ \case
  MyViewKey_Public -> DPushQuery . CovPush' . DMap.mapWithKey f . unCovPull' . unDPullQuery
    where f :: MyViewKeyPublic i -> DPullQuery IdentityInterface i -> DPushQuery IdentityInterface i
          f = \case
            MyViewKeyPublic_NumMessages -> DPushQuery . CovPush' . unCovPull' . unDPullQuery
            MyViewKeyPublic_NumUsers -> DPushQuery . CovPush' . unCovPull' . unDPullQuery
  MyViewKey_Private -> DPushQuery . CovPush' . fmap f . unCovPull' . unDPullQuery
    where f :: These (PossiblyFullCoverage ()) (PossiblyFullCoverage (DMap MyViewKeyPrivate (DPullQuery IdentityInterface))) -> DMap MyViewKeyPrivate (DPushQuery IdentityInterface)
          f x = case x ^? there of
            Nothing -> DMap.empty
            Just (PossiblyFullCoverage_Full _) -> error "Not expecting full coverage"
            Just (PossiblyFullCoverage_NonFull d) -> DMap.mapWithKey g d
              where g :: MyViewKeyPrivate i -> DPullQuery IdentityInterface i -> DPushQuery IdentityInterface i
                    g = \case
                      MyViewKeyPrivate_MyChannels -> DPushQuery . CovPush' . unCovPull' . unDPullQuery
                      MyViewKeyPrivate_ChannelMessages _ -> DPushQuery . CovPush' . unCovPull' . unDPullQuery
                      MyViewKeyPrivate_User _ -> DPushQuery . CovPush' . unCovPull' . unDPullQuery

patchThese1 :: (Push i -> Pull i -> Maybe (Pull i)) -> These1 (DPush IdentityInterface) (DPull IdentityInterface) i -> Maybe (DPull IdentityInterface i)
patchThese1 f = \case
  This1 _ -> trace "patchThese1: warning: push with no corresponding pull" Nothing -- Can't patch what isn't there
  That1 (DPull (Pull'' pull)) -> Just $ DPull $ Pull'' pull
  These1 (DPush (Push'' push)) (DPull (Pull'' pull)) -> DPull . Pull'' <$> f push pull

myViewPatchPullWithPush :: Push MyView -> Pull MyView -> Pull MyView
myViewPatchPullWithPush = alignDMapMaybeWithKey $ \case
  MyViewKey_Public -> patchThese1 $ \push pull -> nothingIf DMap.null $ alignDMapMaybeWithKey f push pull
    where f :: MyViewKeyPublic i -> These1 (DPush IdentityInterface) (DPull IdentityInterface) i -> Maybe (DPull IdentityInterface i)
          f = \case
            MyViewKeyPublic_NumMessages -> patchThese1 $ \(Unitary (Sum push)) (Unitary pull) ->
              Just $ Unitary $ pull + push
            MyViewKeyPublic_NumUsers -> patchThese1 $ \(Unitary (Sum push)) (Unitary pull) ->
              Just $ Unitary $ pull + push
  MyViewKey_Private -> patchThese1 $ \push pull -> nothingIfNull $ catMaybes $ alignWith f push pull
    where f :: These (DMap MyViewKeyPrivate (DPush IdentityInterface)) (Either' AuthenticationError (DMap MyViewKeyPrivate (DPull IdentityInterface))) -> Maybe (Either' AuthenticationError (DMap MyViewKeyPrivate (DPull IdentityInterface)))
          f = \case
            This _ -> trace "patchPullWithPush: warning: push with no corresponding pull" Nothing -- Can't patch what isn't there
            That pull -> Just pull
            These push (Either' pull) -> case pull of
              Left _ -> trace "patchPullWithPush: warning: ignoring patch because Either' is Left" $ Just (Either' pull)
              Right x -> Just $ Either' $ Right $ fmap (alignDMapMaybeWithKey g push) x
                where g :: MyViewKeyPrivate i -> These1 (DPush IdentityInterface) (DPull IdentityInterface) i -> Maybe (DPull IdentityInterface i)
                      g = \case
                        MyViewKeyPrivate_MyChannels -> patchThese1 $ \push' pull' -> Just $ applyAlways push' pull'
                        MyViewKeyPrivate_ChannelMessages _ -> patchThese1 $ \push' pull' -> Just $ applyAlways push' pull'
                        MyViewKeyPrivate_User _ -> patchThese1 $ \push' pull' -> Just $ applyAlways push' pull'

deriveGShow ''MyViewKey
deriveGEq ''MyViewKey
deriveGCompare ''MyViewKey

--TODO: deriveArgDict ''MyViewKey
instance ArgDict c (MyViewKey token) where
  type ConstraintsFor (MyViewKey token) c =
    ( c (DMapInterface MyViewKeyPublic IdentityInterface)
    , c (MapInterface token (AuthenticatedInterface (DMapInterface MyViewKeyPrivate IdentityInterface)))
    )
  argDict = \case
    MyViewKey_Public -> Dict
    MyViewKey_Private -> Dict

deriveGShow ''MyViewKeyPublic
deriveGEq ''MyViewKeyPublic
deriveGCompare ''MyViewKeyPublic
deriveArgDict ''MyViewKeyPublic

deriveGShow ''MyViewKeyPrivate
deriveGEq ''MyViewKeyPrivate
deriveGCompare ''MyViewKeyPrivate
deriveArgDict ''MyViewKeyPrivate

deriveJSONGADT ''MyViewKey
deriveJSONGADT ''MyViewKeyPublic
deriveJSONGADT ''MyViewKeyPrivate
deriveJSONGADT ''MyRequest
